						架构师成长之路 - 互联网架构“高可用”

一、什么是高可用(HA)
    高可用HA(High Availability)是分布式系统架构设计中必须考虑的因素之一,它通常是指，通过设计减少系统不能提供服务的时间。

二、如何保障系统的高可用
    单点是系统高可用的大敌,单点往往是系统高可用最大的风险和敌人,应该尽量在系统设计的过程中避免单点。
    方法论上:高可用保证的原则是"集群化",或者叫"冗余"。
    只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他 backup 能够顶上。
  
 保证系统高可用,架构设计的核心准则是:冗余。
   有了冗余之后，还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务实践。所以，又往往是通过“[【自动故障转移】]”来实现系统的高可用。
 
  互联网架构中通过【冗余+自动故障转移】来保证系统的高可用特性。

三、常见的互联网分层架构，(见图1-1)
   (1)客户端层:      典型的调用方是浏览器browser或者手机应用App
   (2)反向代理层:    系统入口,反向代理
   (3)站点应用层:    实现核心应用逻辑,返回html或者json
   (4)服务层:        如果实现了服务化,就有这一层
   (5)数据-缓存层:   缓存加速访问存储
   (6)数据-数据库层: 数据库固化数据存储

整个系统的高可用,又是通过每一层的冗余+自动故障转移来综合实现的。


四、分层高可用架构实践
  1、【客户端->反向代理层】的高可用,(见图1-2)
       【客户端】到【反向代理层】的高可用,是通过[反向代理层]的[冗余]来实现的。
          以nginx为例:
           有两台nginx,一台对线上提供服务,另一台冗余以保证高可用,常见的实践是keepalived存活探测,相同virtual IP提供服务。
     
       【自动故障转移】:当nginx挂了的时候,keepalived能够探测到,会自动的进行故障转移,将流量自动迁移到shadow-nginx,由于使用的是相同的virtual IP,这个切换过程对调用方是透明的。(见图1-3)
     
  2、【反向代理层->站点层】的高可用,(见图1-4)
       【反向代理层】到【站点层】的高可用,是通过站点层的冗余来实现的。
          假设反向代理层是nginx,nginx.conf里能够配置多个web后端,并且nginx能够探测到多个后端的存活性。
       
       【自动故障转移】:当web-server挂了的时候,nginx能够探测到,会自动的进行故障转移,将流量自动迁移到其他的web-server,整个过程由nginx自动完成,对调用方是透明的。(见图1-5)

  3、【站点层->服务层】的高可用(见图1-6)
       【站点层】到【服务层】的高可用,是通过服务层的冗余来实现的。
	  "服务连接池"会建立与下游服务多个连接,每次请求会"随机"选取连接来访问下游服务。
       
       【自动故障转移】:当service挂了的时候,service-connection-pool能够探测到,会自动进行故障转移,将流量自动迁移到其他的service,整个过程由连接池自动完成,对调用方是透明的(所以说RPC-client中的服务连接池是很重要的基础组件)。(见图1-7)


  4、【服务层->缓存层】的高可用,(见图1-8)
       【服务层】到【缓存层】的高可用,是通过缓存数据的冗余来实现的。
         缓存层的数据冗余又有几种方式:
           ①.利用客户端的封装,service对cache进行双读或者双写。(见图1-9)
           ②.通过支持主从同步的缓存集群来解决缓存层的高可用问题。以redis为例,redis天然支持主从同步,redis官方也有sentinel哨兵机制,来做redis的存活性检测。
       【自动故障转移】:当主redis挂了的时候,sentinel能够探测到,会通知调用方访问其它的redis,整个过程由sentinel和redis集群配合完成,对调用方是透明的。(见图2-0)
          说完缓存的高可用，这里要多说一句，业务对缓存并不一定有“高可用”要求，更多的对缓存的使用场景，是用来“加速数据访问”：把一部分数据放到缓存里，如果缓存挂了或者缓存没有命中，是可以去后端的数据库中再取数据的。

	  这类允许“cache miss”的业务场景，缓存架构的建议是：(见图2-1)
           将kv缓存封装成服务集群，上游设置一个代理（代理可以用集群冗余的方式保证高可用），代理的后端根据缓存访问的key水平切分成若干个实例，每个实例的访问并不做高可用。

          缓存实例挂了屏蔽：当有水平切分的实例挂掉时，代理层直接返回cache miss，此时缓存挂掉对调用方也是透明的。key水平切分实例减少，不建议做re-hash，这样容易引发缓存数据的不一致。(见图2-2)

  5、【服务层->数据库层】的高可用
      数据库层都用了"主从同步,读写分离"架构,所以数据库层的高可用又分为:"读库高可用"与"写库高可用"两类。
          
      
      5.1【服务层->数据库层"读"】的高可用,(见图2-3)
           【服务层】到【数据库读】的高可用,是通过读库的冗余来实现的。
              既然冗余了读库，一般来说就至少有 2 个从库，“数据库连接池”会建立与读库多个连接，每次请求会路由到这些读库。
           
           【自动故障转移】:当读库挂了的时候，db-connection-pool 能够探测到，会自动的进行故障转移，将流量自动迁移到其他的读库，整个过程由连接池自动完成，对调用方是透明的（所以说 DAO 中的数据库连接池是很重要的基础组件）。(见图2-4)

      5.2【服务层->数据库层"写"】的高可用,(见图2-5)
	    【服务层】到【数据库写】的高可用,是通过写库的冗余来实现的。
               以 mysql 为例，可以设置两个 mysql 双主同步，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是 keepalived 存活探测，相同 virtual IP 提供服务。

            【自动故障转移】:当写库挂了的时候，keepalived 能够探测到，会自动的进行故障转移，将流量自动迁移到 shadow-db-master，由于使用的是相同的 virtual IP，这个切换过程对调用方是透明的。(见图2-6)


五、总结
   高可用HA(High Availablity)是分布式系统架构设计中必须考虑的因素之一,它通常是指,通过设计减少系统不能提供服务的时间。
   方法论上,高可用是通过:【冗余+自动故障转移】来实现的。
   整个互联网分层系统架构的高可用，又是通过每一层的冗余 + 自动故障转移来综合实现的，具体的：
     （1）【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余实现的，常见实践是 keepalived + virtual IP 自动故障转移

     （2）【反向代理层】到【站点层】的高可用，是通过站点层的冗余实现的，常见实践是 nginx 与 web-server 之间的存活性探测与自动故障转移

     （3）【站点层】到【服务层】的高可用，是通过服务层的冗余实现的，常见实践是通过 service-connection-pool 来保证自动故障转移

     （4）【服务层】到【缓存层】的高可用，是通过缓存数据的冗余实现的，常见实践是缓存客户端双读双写，或者利用缓存集群的主从数据同步与 sentinel 保活与自动故障转移；更多的业务场景，对缓存没有高可用要求，可以使用缓存服务化来对调用方屏蔽底层复杂性

     （5）【服务层】到【数据库“读”】的高可用，是通过读库的冗余实现的，常见实践是通过 db-connection-pool 来保证自动故障转移

     （6）【服务层】到【数据库“写”】的高可用，是通过写库的冗余实现的，常见实践是 keepalived + virtual IP 自动故障转移

          末了，希望文章的思路是清晰的，希望大家对高可用的概念和实践有个系统的认识，感谢大家。




转自:https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959728&idx=1&sn=933227840ec8cdc35d3a33ae3fe97ec5&chksm=bd2d046c8a5a8d7a13551124af36bedf68f7a6e31f6f32828678d2adb108b86b7e08c678f22f&scene=21##







