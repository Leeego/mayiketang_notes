						  Http协议和Web应用有状态和无状态
1、什么是Web应用程序的无状态性?
   说基于 http 协议的 web 应用程序是请求――应答模式是无状态的，我们可以这样理解：每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况。

2、如何使我们的web应用是有状态?
   在http协议的基础上,web应用引入cookies、session、application保持web应用之间的状态。
   注：
     cookies,session，application 都不是标准协议，但是各种网络应用提供商，实现语言、web 容器都默认支持它。当然这种支持与对网络标准协议的支持是不同的，标准协议规定的接口，而这种机制只是规定了思想。
     其实从我们上面的分析看来，application 不应该被视为这种意义上出现的维护状态的机制。它是决定怎么应用程序的“配制文件”。但是如果你从这种状态维持机制所覆盖的范围来推导，你会发现，application 好像也算得上。

Session 所控制的范围是一个 session。一个会话，会话从第一次访问服务器开始存在，到服务器调用 session.invalidator()（可能是超时，可能是其它原因）。

Cookies 所控制的范围有它自己的定义(与 session 没有直接的关系)，可以长可以短。只要服务器放在用户文件系统中的 cookies 没有被删除，至少服务器还识别它。它的控制范围就是还在的。

这个角度上讲，Session 和 Cookies 都可以归为跨页面的状态。但是 session 跨不出一次会话，Cookies 跨不出两端的限制。

Application，则是关联这个网络应用程序的。

--------------------------------------------------
举例：

有人将 web 应用中有无状态的情况，比着顾客逛商店的情景。

顾客：浏览器访问方；

商店：web 服务器；

一次购买：一次 http 访问

我们知道，上一次顾客购买，并不代表顾客下一个小时一定会买（当然也不能代表不会）。也就是说同一个顾客的不同购买之间的关系是不定的。所以说实在的，这种情况下，让商店保存所有的顾客购买的信息，等到下一次购买可以知道这个顾客以前购买的内容代价非常大的。所以商店为了避免这个代价，索性就认为每次的购买都是一次独立的新的购买。浅台词：商店不区分对待老顾客和新过客。这就是无状态的。

但是，商店为了提高收益。她是想鼓励顾客购买的。所以告诉你，只要你在一个月内购买了５瓶以上的啤酒，就送你一个酒杯。

我们看看这种情况我们怎么去实现呢？

A, 给顾客发放一个磁卡，里面放有顾客过去的购买信息。

这样商店就可以知道了。这就是 cookie.

B, 给顾客发放一个唯一号码，号码制定的顾客的消费信息，存储在商店的服务器中。这就是 session。

最后，商店可以全局的决定，是５瓶为送酒杯还是 6 瓶。这就是 application。

其实，这些机制都是在无状态的传统购买过程中加入了一点东西，使整个过程变得有状态。Web 应用就是这样的。




     