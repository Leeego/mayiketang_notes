					      Mysql中的行级锁、表级锁、页级锁
锁是在执行多线程时用于强行限制资源访问的同步机制,即用于在并发控制中保证对互斥要求的满足。
在《数据库的锁机制》中,在DBMS中,可以按照<锁的粒度>把<数据库锁>分为:行级锁(innodb引擎)、表级锁(myisam引擎)、页级锁(BDB引擎)。
=============================================================
1、行级锁
行级锁是mysql中锁定粒度最细的一种锁,表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小,但加锁的开销也最大。
行级锁分为:<共享锁>和<排他锁>。
特点:
 开销大,加锁慢;会出现死锁;锁定粒度最小,发生锁冲突的概念最低,并发度也最高。
=============================================================
2、表级锁
表级锁是Mysql中锁定粒度最大的一种锁,表示对当前操作的整张表加锁,它实现简单,资源消耗较少,被大部分Mysql引擎支持。最常使用的Myisam和innodb都支持表级锁。
表级锁分为:<表共享读锁>(共享锁)和<表独占写锁>(排他锁)。
特点:
  开销小,加锁快,不会出现死锁;锁定粒度大,发生锁冲突的概率最高,并发度最低。
=============================================================
3、页级锁
页级锁是Mysql中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快,但冲突多,行级锁冲突少,但速度慢。所以取了折中的页级,《一次锁定相邻的一组记录》。<BDB>支持页级锁。
特点:
 开销和加锁时间介于表锁和行锁之间;会出现死锁;锁定粒度介于表锁和行锁之间,并发度一般。
=============================================================
MYSQL常用存储引擎的锁机制
myisam、memory:表级锁(table-level locking)
BDB:           页级锁(page-level locking)或表级锁,默认为页级锁
Innodb:	       行级锁(row-level locking)和表级锁,默认为行级锁
=============================================================
InnoDB中的行锁与表锁
行锁:只锁住一行
表锁:锁住整张表
innodb<行锁>是通过给<索引>上的<索引项加锁>来实现的,这一点Mysql和Oracle不同,Oracle是通过在<数据块>中对<相应数据行加锁>来实现的。
innodb这种行锁实现特点意味着:只有通过<索引条件><检索数据>,innodb才使用<行级锁>,否则,innodb将使用<表锁>!

在实际应用中，要特别注意 《InnoDB 行锁》的这一特性，不然的话，可能导致大量的《锁冲突》，从而影响《并发》性能。
.在<不通过索引条件查询>的时候,<innodb>确实使用的是<表锁>,而不是行锁。
.由于Mysql的行锁是针对索引加的锁,不是针对记录加的锁,所以虽然是访问不同的行的记录,但是如果是使用相同的索引键,是会出现锁冲突的。应用设计的时候要注意这一点。
.当表有多个索引的时候, 不同的事务可以使用不同的索引锁定不同的行, 另外, 不论 是使用主键索引、唯一索引或普通索引,InnoDB 都会使用行锁来对数据加锁。
. 即便在条件中使用了索引字段, 但是否使用索引来检索数据是由 MySQL 通过判断不同 执行计划的代价来决定的, 如果 MySQL 认为全表扫 效率更高, 比如对一些很小的表, 它 就不会使用索引, 这种情况下 InnoDB 将使用表锁, 而不是行锁。因此, 在分析锁冲突时, 别忘了检查 SQL 的执行计划, 以确认是否真正使用了索引。
=============================================================
行级锁与死锁
Myisam中是不会产生死锁的,因为Myisam总是一次性获得所需要的全部锁,要么全部满足,要么全部等待。
Innodb中,锁是逐步获得的,就造成了死锁的可能。

在Mysql中,<行级锁>并<不是>直接<锁记录>,而是<锁><索引>。
<索引>分为:<主键索引>和<非主键索>引两种。
-如果一条sql语句操作了主键索引,Mysql会锁定这条主键索引;
-如果一条sql语句操作了非主键索引,Mysql会先锁定该非主键索引,再锁定相关的主键索引。
在update、delete操作时,Mysql不仅锁定where条件扫描过的所有索引记录,而且会锁定相邻的键值,即所谓的next-key locking。

--死锁
当两个事务同时执行,一个锁住了主键索引,在等待其他相关索引。另一个锁定了非主键索引,在等待主键索引。这样就会发生死锁。
发生死锁后,innodb一般都可以检测到,并使一个事务释放锁回退,另一个获取锁完成事务。
=============================================================
多种方法可以避免死锁,这里只介绍常见三种
①.如果<不同程序>会<并发><存取多个表>,尽量约定以<相同的顺序访问表>,可以大大降低死锁机会。
②.在<同一个事务>中,尽可能做到<一次锁定所需要的所有资源>,减少死锁产生概率。
③.对于非常容易产生死锁的业务部分,可以尝试使用升级锁定颗粒度,通过表级锁来减少死锁产生的概率。


















